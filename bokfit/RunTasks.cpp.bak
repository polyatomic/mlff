#include <iostream>
#include <iomanip>
#include <algorithm>

#include "chemutil.h"
#include "RunTasks.h"
#include "util.h"
#include "Descriptors.h"
#include "tasks.h"
#include "mathutil.h"

extern PType g_params;

using std::cerr;
using std::cout;
using std::endl;
using std::numeric_limits;
using std::streamsize;
using std::setprecision;
using std::set_difference;
using std::sort;
using std::ofstream;

void analyze_triplet(Triplet& t, int na, int i, int j, int k, int pids[]) {
   int itmp;
   if (t.v[0] == t.v[1]) {
      if (t.v[1] == t.v[2]) {
         // AAA
         pids[0] = IDX(na,i,j);
         pids[1] = IDX(na,i,k);
         pids[2] = IDX(na,j,k);
      } else {
         // AAB -> kij
         itmp = t.v[0];
         t.v[0] = t.v[2];
         t.v[2] = itmp;
         pids[0] = IDX(na,i,k);
         pids[1] = IDX(na,j,k);
         pids[2] = IDX(na,i,j);
      }
   } else {
      if (t.v[1] == t.v[2]) {
         // ABB
         pids[0] = IDX(na,i,j);
         pids[1] = IDX(na,i,k);
         pids[2] = IDX(na,j,k);
      } else {
         // ABA -> jik
         itmp = t.v[0];
         t.v[0] = t.v[1];
         t.v[1] = itmp;
         pids[0] = IDX(na,i,j);
         pids[1] = IDX(na,j,k);
         pids[2] = IDX(na,i,k);
      }
   }
}

void analyze_quadruplet(Quadruplet& q, int na, int i, int j, int k, int l, int pids[]) {
   int itmp;
   if (q.v[0] == q.v[1]) {
      if (q.v[1] == q.v[2]) {
         if (q.v[2] == q.v[3]) {
            // AAAA
            pids[0] = IDX(na, i, j);
            pids[1] = IDX(na, i, k);
            pids[2] = IDX(na, i, l);
            pids[3] = IDX(na, j, k);
            pids[4] = IDX(na, j, l);
            pids[5] = IDX(na, k, l);
         } else {
            // AAAB -> lijk
            itmp = q.v[0];
            q.v[0] = q.v[3];
            q.v[3] = itmp;
            pids[0] = IDX(na, i, l);
            pids[1] = IDX(na, j, l);
            pids[2] = IDX(na, k, l);
            pids[3] = IDX(na, i, j);
            pids[4] = IDX(na, i, k);
            pids[5] = IDX(na, j, k);
         }
      } else {
         if (q.v[2] == q.v[3]) {
            if (q.v[1] > q.v[2]) {
               // BBAA -> klij
               itmp = q.v[0];
               q.v[0] = q.v[2];
               q.v[2] = itmp;
               itmp = q.v[1];
               q.v[1] = q.v[3];
               q.v[3] = itmp;
               pids[0] = IDX(na, k, l);
               pids[1] = IDX(na, i, k);
               pids[2] = IDX(na, j, k);
               pids[3] = IDX(na, i, l);
               pids[4] = IDX(na, j, l);
               pids[5] = IDX(na, i, j);
            } else {
               // AABB
               pids[0] = IDX(na, i, j);
               pids[1] = IDX(na, i, k);
               pids[2] = IDX(na, i, l);
               pids[3] = IDX(na, j, k);
               pids[4] = IDX(na, j, l);
               pids[5] = IDX(na, k, l);
            }
         } else {
            // AABA -> kjil
            itmp = q.v[0];
            q.v[0] = q.v[2];
            q.v[2] = itmp;
            pids[0] = IDX(na, j, k);
            pids[1] = IDX(na, i, k);
            pids[2] = IDX(na, k, l);
            pids[3] = IDX(na, i, j);
            pids[4] = IDX(na, j, l);
            pids[5] = IDX(na, i, l);
         }
      }
   } else {
      if (q.v[1] == q.v[2]) {
         if (q.v[2] == q.v[3]) {
            // ABBB
            pids[0] = IDX(na, i, j);
            pids[1] = IDX(na, i, k);
            pids[2] = IDX(na, i, l);
            pids[3] = IDX(na, j, k);
            pids[4] = IDX(na, j, l);
            pids[5] = IDX(na, k, l);
         } else {
            if (q.v[0] < q.v[1]) {
               // ABBA -> iljk 
               itmp = q.v[1];
               q.v[1] = q.v[3];
               q.v[3] = itmp;
               pids[0] = IDX(na, i, l);
               pids[1] = IDX(na, i, j);
               pids[2] = IDX(na, i, k);
               pids[3] = IDX(na, j, l);
               pids[4] = IDX(na, k, l);
               pids[5] = IDX(na, j, k);
            } else {
               // BAAB -> kjil
               itmp = q.v[0];
               q.v[0] = q.v[2];
               q.v[2] = itmp;
               pids[0] = IDX(na, j, k);
               pids[1] = IDX(na, i, k);
               pids[2] = IDX(na, k, l);
               pids[3] = IDX(na, i, j);
               pids[4] = IDX(na, j, l);
               pids[5] = IDX(na, i, l);
            }
         }
      } else {
         if (q.v[2] == q.v[3]) {
            // ABAA -> jikl
            itmp = q.v[1];
            q.v[1] = q.v[0];
            q.v[0] = itmp;
            pids[0] = IDX(na, i, j);
            pids[1] = IDX(na, j, k);
            pids[2] = IDX(na, j, l);
            pids[3] = IDX(na, i, k);
            pids[4] = IDX(na, i, l);
            pids[5] = IDX(na, k, l);
         } else {
            if (q.v[1] < q.v[2]) {
               // BABA -> ljki
               itmp = q.v[0];
               q.v[0] = q.v[3];
               q.v[3] = itmp;
               pids[0] = IDX(na, j, l);
               pids[1] = IDX(na, k, l);
               pids[2] = IDX(na, i, l);
               pids[3] = IDX(na, j, k);
               pids[4] = IDX(na, i, j);
               pids[5] = IDX(na, i, k);
            } else {
               // ABAB -> ikjl
               itmp = q.v[1];
               q.v[1] = q.v[2];
               q.v[2] = itmp;
               pids[0] = IDX(na, i, k);
               pids[1] = IDX(na, i, j);
               pids[2] = IDX(na, i, l);
               pids[3] = IDX(na, j, k);
               pids[4] = IDX(na, k, l);
               pids[5] = IDX(na, j, l);
            }
         }
      }
   }
}

int GetSubType(Triplet& t) {
   if (t.v[0] == t.v[1]) {
      if (t.v[1] == t.v[2]) {
         return 0;
      }
   }
   return 1;
}

int GetSubType(Quadruplet& q) {
   int i, comp, count;
   comp = q.v[0];
   for (i = 1, count = 1; i < 4; i++) {
      if (q.v[i] == comp) count++;
   }
   if (count == 2) return 2;
   if (count == 4) return 0;
   return 1;
}

void RunTasks() {
   int i, j, k, l, nstr, na, n, nt1, nt2, nt4, tp, m, ndesc, ndesc20, ndesc21, ndesc22, n_train3, ndesc4, ndesc40, ndesc41, ndesc23,
       nt3, na3, o, ndesc2, na4, ii, jj, kk, ndiff, n_train2, ndesc3, ndesc30, ndesc31, ndesc32, ndesc33, ndesc42, ndesc43, ndesc44, n_train23;
   int *types2, *ngp, *ids_selected2, *types3, *stypes3,
       *types4, *stypes4, *idit, *itmp, *ids_selected3, *ids_selected23;
   double avg;
   double *Y, *v, *dmin, *dmax, *rcoords, *stdevs, *avgs, *wmatc, *Yc;
   int pids[6] = {};
   int n_train2B[3] = {};
   int *ids_selected2o[3] = {};
   int n_train3B[4] = {};
   int n_train4B[5] = {};
   int *ids_selected3o[4] = {};
   int *ids_selected4o[5] = {};
   int ndescs[12] = {};
   int *ids_selected[12] = {};
   double *levs[12] = {};
   Pair p;
   Triplet t;
   Quadruplet q;
   vector<int> t1;
   vector<Pair> t2;
   vector<Triplet> t3;
   vector<Quadruplet> t4;
   Iterator<Mol> mols;
   vector<string> tkns, tkns2;
   vector<Pair>::iterator t2pos;
   vector<Triplet>::iterator t3pos;
   vector<Quadruplet>::iterator t4pos;
   set<int> pss[3];
   set<Triplet, TripletCompare> tss[4];
   set<Triplet, TripletCompare> tss_ref[4];
   set<Triplet, TripletCompare>::iterator it, it2;
   set<Sixtuplet, SixtupletCompare> sss[5];
   set<Sixtuplet, SixtupletCompare> sss_ref[5];
   set<Sixtuplet, SixtupletCompare>::iterator its, its2;
   set<int>::iterator itp;
   vector<int> ivec;
   ofstream ofile;
   int prec = numeric_limits<double>::max_digits10;
   streamsize oldprec = cout.precision();
   string s = g_params.molFile;
   mols = ReadXYZFile(s.c_str());
   if (!mols) {
      cerr << "Error opening " << s << endl;
      return;
   }
   nstr = mols.Size();
   cout << "Number of training configurations = " << nstr << endl;
   na = mols[0].NAtoms();
   cout << "Number of atoms in configuration = " << na << endl;
   s = g_params.eFile;
   Y = new double[nstr];
   if (s.size() > 0) {
      if (!File2Array(s, Y)) {
         cerr << "Error reading " << s << endl;
         delete [] Y;
         return;
      }
   } else {
      cerr << "Input error" << endl;
      delete [] Y;
      return;
   }
   n = 3*na;
   j = nstr*n;
   v = new double[j];
   for (i=0; i < nstr; i++) mols[i].GetCoordinates(v + i*n);
   mols.Resize(1);
   Descriptors descs;
   TFunctorDaDaI<Descriptors> dcalc;
   tkns = Tokenize(g_params.t1, "\r\n");
   nt1 = tkns.size();
   cout << "Number of atom types = " << nt1 << endl;
   cout << "Atom types:" << endl;
   for (i = 0; i < nt1; i++) {
      j = atoi(tkns[i].c_str());
      t1.push_back(j);
      cout << Atom::GetAtomicSymbol(j) << endl;
   }
   tkns = Tokenize(g_params.t2, "\r\n");
   nt2 = tkns.size();
   cout << "Number of atom type pairs = " << nt2 << endl;
   for (i = 0; i < nt2; i++) {
      tkns2 = Tokenize(tkns[i], " ");
      j = atoi(tkns2[0].c_str());
      p.v[0] = j;
      j = atoi(tkns2[1].c_str());
      p.v[1] = j;
      t2.push_back(p);
   }
   dmin = new double[nt2];
   dmax = new double[nt2];
   types2 = new int[na*(na-1)/2];
   for (i = 0, m = 0; i < na-1; i++) {
      k = mols[0].GetAtomicNumber(i);
      for (j = i+1; j < na; j++) {
         p.v[0] = k;
         p.v[1] = mols[0].GetAtomicNumber(j);
         if (p.v[0] > p.v[1]) { l = p.v[0]; p.v[0] = p.v[1]; p.v[1] = l; }
         t2pos = lower_bound(t2.begin(), t2.end(), p, PairCompare());
         tp = t2pos - t2.begin();
         types2[m++] = tp;
      }
   }
   tkns = Tokenize(g_params.t3, "\r\n");
   nt3 = tkns.size();
   cout << "Number of atom type triplets = " << nt3 << endl;
   for (i = 0; i < nt3; i++) {
      tkns2 = Tokenize(tkns[i], " ");
      j = atoi(tkns2[0].c_str());
      t.v[0] = j;
      j = atoi(tkns2[1].c_str());
      t.v[1] = j;
      j = atoi(tkns2[2].c_str());
      t.v[2] = j;
      t3.push_back(t);
   }
   na3 = na*(na-1)*(na-2)/6;
   types3 = new int[4*na3];
   stypes3 = new int[nt3];
   for (i=0; i < nt3; i++) stypes3[i] = GetSubType(t3[i]);
   for (i = 0,o = 0; i < na-2; i++) {
      l = mols[0].GetAtomicNumber(i);
      for (j = i+1; j < na-1; j++) {
         m = mols[0].GetAtomicNumber(j);
         for (k = j+1; k < na; k++) {
            t.v[0] = l;
            t.v[1] = m;
            t.v[2] = mols[0].GetAtomicNumber(k);
            analyze_triplet(t, na, i, j, k, pids);
            t3pos = find(t3.begin(), t3.end(), t);
            tp = t3pos - t3.begin();
            types3[o] = tp;
            types3[na3+3*o] = pids[0]; types3[na3+3*o+1] = pids[1]; types3[na3+3*o+2] = pids[2];
            o++;
         }
      }
   }
   tkns = Tokenize(g_params.t4, "\r\n");
   nt4 = tkns.size();
   cout << "Number of atom type quadruplets = " << nt4 << endl;
   for (i = 0; i < nt4; i++) {
      tkns2 = Tokenize(tkns[i], " ");
      j = atoi(tkns2[0].c_str());
      q.v[0] = j;
      j = atoi(tkns2[1].c_str());
      q.v[1] = j;
      j = atoi(tkns2[2].c_str());
      q.v[2] = j;
      j = atoi(tkns2[3].c_str());
      q.v[3] = j;
      t4.push_back(q);
   }
   na4 = na*(na-1)*(na-2)*(na-3)/24;
   types4 = new int[7*na4];
   stypes4 = new int[nt4];
   for (i=0; i < nt4; i++) stypes4[i] = GetSubType(t4[i]);
   for (i=0,o=0; i < na-3; i++) {
      ii = mols[0].GetAtomicNumber(i);
      for (j=i+1; j < na-2; j++) {
         jj = mols[0].GetAtomicNumber(j);
         for (k=j+1; k < na-1; k++) {
            kk = mols[0].GetAtomicNumber(k);
            for (l=k+1; l < na; l++) {
               q.v[0] = ii;
               q.v[1] = jj;
               q.v[2] = kk;
               q.v[3] = mols[0].GetAtomicNumber(l);
               analyze_quadruplet(q, na, i, j, k, l, pids);
               t4pos = find(t4.begin(), t4.end(), q);
               tp = t4pos - t4.begin();
               types4[o] = tp;
               types4[na4+6*o] = pids[0]; types4[na4+6*o+1] = pids[1]; types4[na4+6*o+2] = pids[2]; types4[na4+6*o+3] = pids[3]; types4[na4+6*o+4] = pids[4]; types4[na4+6*o+5] = pids[5];
               o++;
            }
         }
      }
   }
   ngp = new int[nt2];
   tkns = Tokenize(g_params.ngp, "\r\n");
   stdevs = avgs = wmatc = Yc = 0;
   ids_selected2 = itmp = ids_selected3 = ids_selected23 = 0;
   if (tkns.size() != nt2) {
      cerr << "Input error reading NUMBER_OF_GRID_POINTS" << endl;
      goto end;
   }
   for (i = 0; i < nt2; i++)
      ngp[i] = atoi(tkns[i].c_str());
   descs.Init(na, nt2, types2, nt3, stypes3, types3, nt4, stypes4, types4, ngp, g_params.nthreads);
   if (g_params.dist.size() == 0) {
      for (i = 0; i < nt2; i++) {
         dmin[i] = 1000.0;
         dmax[i] = 0.0;
      }
      for (i = 0; i < nstr; i++) {
         rcoords = v + i*n;
         descs.GetDistanceRanges(rcoords, dmin, dmax);
      }
   }
   cout << "Atom type pairs, minimum and maximum distances, max-min and number of grid points:" << endl;
   for (i = 0; i < nt2; i++)
      cout << Atom::GetAtomicSymbol(t2[i].v[0]) << " " << Atom::GetAtomicSymbol(t2[i].v[1]) << " " << setprecision(prec) << dmin[i] << " " << dmax[i] << " " << setprecision(oldprec) << dmax[i] - dmin[i] << " " << ngp[i] << endl;
   descs.SetGrid(dmin, dmax);
   if (g_params.preselect_descriptors) {
      for (i = 0; i < nstr; i++) {
         rcoords = v + i*n;
         descs.FindClosestMultiplets(rcoords, pss, tss, sss);
      }
      cout << "2B descriptors selected according to closeness to training points" << endl;
      for (i = 0; i < 3; i++) {
         cout << "Descriptors of type " << i << endl;
         if (i == 0) ofile.open("g20.txt");
         else if (i == 1) ofile.open("g21.txt");
         else ofile.open("g22.txt");
         cout << pss[i].size() << endl;
         ofile << pss[i].size() << endl;
         for (itp = pss[i].begin(); itp != pss[i].end(); itp++) {
            cout << *itp << endl;
            ofile << *itp << endl;
         }
         ofile.close();
      }
      descs.Get3BGridPoints(tss_ref);
      cout << "3B descriptors selected according to closeness to training points" << endl;
      for (i = 0; i < 4; i++) {
         ivec.clear();
         cout << "Descriptors of type " << i << endl;
         cout << tss[i].size() << endl;
         j = 0;
         for (it = tss[i].begin(); it != tss[i].end(); it++) {
            it2 = tss_ref[i].find(*it);
            if (it2 != tss_ref[i].end()) {
               cout << (*it).v[0] << " " << (*it).v[1] << " " << (*it).v[2] << endl;
               ivec.push_back((*it).v[0]); ivec.push_back((*it).v[1]); ivec.push_back((*it).v[2]);
               j++;
            } else {
               cerr << (*it).v[0] << " " << (*it).v[1] << " " << (*it).v[2] << " not found for type " << i << endl;
            }
         }
         cout << j << endl;
         if (j > 0) {
            if (i == 0) ofile.open("g30.txt");
            else if (i == 1) ofile.open("g31.txt");
            else if (i == 2) ofile.open("g32.txt");
            else ofile.open("g33.txt");
            ofile << j << endl;
            for (k=0; k < j; k++) {
               ofile << ivec[k*3] << " " << ivec[k*3+1] << " " << ivec[k*3+2] << endl;
            }
            ofile.close();
         }
      }
      descs.Get4BGridPoints(sss_ref);
      cout << "4B descriptors selected according to closeness to training points" << endl;
      for (i = 0; i < 5; i++) {
         ivec.clear();
         cout << "Descriptors of type " << i << endl;
         cout << sss[i].size() << endl;
         j = 0;
         for (its = sss[i].begin(); its != sss[i].end(); its++) {
            its2 = sss_ref[i].find(*its);
            if (its2 != sss_ref[i].end()) {
               cout << (*its).v[0] << " " << (*its).v[1] << " " << (*its).v[2] << " " << (*its).v[3] << " " << (*its).v[4] << " " << (*its).v[5] << endl;
               ivec.push_back((*its).v[0]); ivec.push_back((*its).v[1]); ivec.push_back((*its).v[2]); ivec.push_back((*its).v[3]); ivec.push_back((*its).v[4]); ivec.push_back((*its).v[5]);
               j++;
            } else {
               cerr << (*its).v[0] << " " << (*its).v[1] << " " << (*its).v[2] << " " << (*its).v[3] << " " << (*its).v[4] << " " << (*its).v[5] << " not found for type " << i << endl;
            }
         }
         cout << j << endl;
         if (j > 0) {
            if (i == 0) ofile.open("g40.txt");
            else if (i == 1) ofile.open("g41.txt");
            else if (i == 2) ofile.open("g42.txt");
            else if (i == 3) ofile.open("g43.txt");
            else ofile.open("g44.txt");
            ofile << j << endl;
            for (k = 0; k < j; k++) {
               ofile << ivec[k*6] << " " << ivec[k*6+1] << " " << ivec[k*6+2] << " " << ivec[k*6+3] << " " << ivec[k*6+4] << " " << ivec[k*6+5] << endl;
            }
            ofile.close();
         }
      }
      ivec.clear();
      goto end;
   }
   Descriptors::SetKernel2B(0);
   Descriptors::SetKernel3B(0);
   Descriptors::SetKernel4B(0);
   ndesc = descs.GetNDescriptors();
   stdevs = new double[ndesc];
   avgs = new double[ndesc];
   for (i=0; i < 12; i++) ids_selected[i] = new int[nstr];
   for (i=0; i < 12; i++) levs[i] = new double[nstr];
   wmatc = new double[nstr*ndesc];
   cout << "Number of descriptors: " << ndesc << endl;
   dcalc.init(&descs, &Descriptors::Calculate);
   if (!g_params.read_descriptors) {
      calculate_descriptors(nstr, ndesc, n, v, &dcalc, stdevs, avgs, wmatc, g_params.nthreads, g_params.maxrows);
      // Matrix2File(wmatc, nstr, ndesc, "descs.bin");
      //Matrix2File(stdevs, ndesc, 1, "stdevs.bin");
      //Matrix2File(avgs, ndesc, 1, "avgs.bin");
      // goto end;
   } else {
      // Add error handling here for the case bin files don't exist
      // File2Matrix("descs.bin", nstr, ndesc, wmatc);
      File2Matrix("stdevs.bin", ndesc, i, stdevs);
      File2Matrix("avgs.bin", ndesc, i, avgs);
   }
   ndesc2 = descs.GetN2BDescriptors();
   cout << "Number of 2B descriptors: " << ndesc2 << endl;
   ndesc20 = descs.GetN2BDescriptors(0);
   ndesc21 = descs.GetN2BDescriptors(1);
   ndesc22 = descs.GetN2BDescriptors(2);
   cout << "   type 0: " << ndesc20 << endl;
   cout << "   type 1: " << ndesc21 << endl;
   cout << "   type 2: " << ndesc22 << endl;
   tkns = Tokenize(g_params.tss2B, " ");
   if (tkns.size() != 3) {
      cerr << "Input error reading TRAINING_SET_SIZE_2B" << endl;
      goto end;
   }
   for (i=0; i < 3; i++) {
      n_train2B[i] = atoi(tkns[i].c_str());
      ids_selected2o[i] = new int[n_train2B[i]];
   }
   Yc = new double[nstr];
   for (i = 0, avg = 0.0; i < nstr; i++) avg += Y[i];
   avg /= nstr;
   for (i = 0; i < nstr; i++) Yc[i] = Y[i] - avg;
   ndescs[0] = ndesc20;
   ndescs[1] = ndesc21;
   ndescs[2] = ndesc22;
   /*ndesc3 = descs.GetN3BDescriptors();
   cout << "Number of 3B descriptors: " << ndesc3 << endl;
   ndesc30 = descs.GetN3BDescriptors(0);
   ndesc31 = descs.GetN3BDescriptors(1);
   ndesc32 = descs.GetN3BDescriptors(2);
   ndesc33 = descs.GetN3BDescriptors(3);
   cout << "   type 0: " << ndesc30 << endl;
   cout << "   type 1: " << ndesc31 << endl;
   cout << "   type 2: " << ndesc32 << endl;
   cout << "   type 3: " << ndesc33 << endl;
   ndescs[3] = ndesc30;
   ndescs[4] = ndesc31;
   ndescs[5] = ndesc32;
   ndescs[6] = ndesc33;
   ndesc4 = descs.GetN4BDescriptors();
   cout << "Number of 4B descriptors: " << ndesc4 << endl;
   ndesc40 = descs.GetN4BDescriptors(0);
   ndesc41 = descs.GetN4BDescriptors(1);
   ndesc42 = descs.GetN4BDescriptors(2);
   ndesc43 = descs.GetN4BDescriptors(3);
   ndesc44 = descs.GetN4BDescriptors(4);
   cout << "   type 0: " << ndesc40 << endl;
   cout << "   type 1: " << ndesc41 << endl;
   cout << "   type 2: " << ndesc42 << endl;
   cout << "   type 3: " << ndesc43 << endl;
   cout << "   type 4: " << ndesc44 << endl;
   ndescs[7] = ndesc40;
   ndescs[8] = ndesc41;
   ndescs[9] = ndesc42;
   ndescs[10] = ndesc43;
   ndescs[11] = ndesc44;*/
   // order_by_leverages(nstr, ndescs, 12, "descs.bin", ids_selected, levs, g_params.maxrows, g_params.nthreads);
   ndescs[0] = ndesc2;
   order_by_leverages(nstr, ndescs[0], wmatc, ids_selected[0], levs[0]);

   /*cout << "ntrain2B(0): " << n_train2B[0] << ", max_lev: " << levs[0][ids_selected[0][0]] << ", min_lev: " << levs[0][ids_selected[0][n_train2B[0] - 1]] << endl;
   for (i=0; i < n_train2B[0]; i++) ids_selected2o[0][i] = ids_selected[0][i];
   sort(ids_selected2o[0], ids_selected2o[0]+n_train2B[0]);
   cout << "ntrain2B(1): " << n_train2B[1] << ", max_lev: " << levs[1][ids_selected[1][0]] << ", min_lev: " << levs[1][ids_selected[1][n_train2B[1]-1]] << endl;
   for (i=0; i < n_train2B[1]; i++) ids_selected2o[1][i] = ids_selected[1][i];
   sort(ids_selected2o[1], ids_selected2o[1]+n_train2B[1]);
   cout << "ntrain2B(2): " << n_train2B[2] << ", max_lev: " << levs[2][ids_selected[2][0]] << ", min_lev: " << levs[2][ids_selected[2][n_train2B[2]-1]] << endl;
   for (i=0; i < n_train2B[2]; i++) ids_selected2o[2][i] = ids_selected[2][i];
   sort(ids_selected2o[2], ids_selected2o[2]+n_train2B[2]);
   ids_selected2 = new int[nstr];
   for (i=0; i < n_train2B[0]; i++) ids_selected2[i] = ids_selected2o[0][i];
   idit = set_difference(ids_selected2o[1], ids_selected2o[1]+n_train2B[1], ids_selected2, ids_selected2+n_train2B[0], ids_selected2+n_train2B[0]);
   ndiff = idit - (ids_selected2 + n_train2B[0]);
   n_train2 = n_train2B[0] + ndiff;
   sort(ids_selected2, ids_selected2+n_train2);
   idit = set_difference(ids_selected2o[2], ids_selected2o[2]+n_train2B[2], ids_selected2, ids_selected2+n_train2, ids_selected2+n_train2);
   ndiff = idit - (ids_selected2 + n_train2);
   n_train2 += ndiff;
   sort(ids_selected2, ids_selected2+n_train2);*/
   itmp = new int[nstr];
   for (i = 0; i < nstr; i++) itmp[i] = i;
   ids_selected2 = new int[nstr];
   n_train2 = n_train2B[0];
   for (i = 0; i < n_train2; i++) ids_selected2[i] = ids_selected[0][i];
   sort(ids_selected2, ids_selected2+n_train2);
   set_difference(itmp, itmp+nstr, ids_selected2, ids_selected2+n_train2, ids_selected2+n_train2);
   //calculate_linear_regression(nstr, ndesc2, ndesc, "descs.bin", ids_selected2, n_train2, Yc);
   for (i=0; i < n_train2; i++)
      cout << ids_selected2[i] << endl;
   calculate_linear_regression(nstr, ndesc2, wmatc, ids_selected2, n_train2, Yc);

   /*tkns = Tokenize(g_params.tss3B, " ");
   if (tkns.size() != 4) {
      cerr << "Input error reading TRAINING_SET_SIZE_3B" << endl;
      goto end;
   }
   for (i = 0; i < 4; i++) {
      n_train3B[i] = atoi(tkns[i].c_str());
      ids_selected3o[i] = new int[n_train3B[i]];
   }
   cout << "ntrain3B(0): " << n_train3B[0] << ", max_lev: " << levs[3][ids_selected[3][0]] << ", min_lev: " << levs[3][ids_selected[3][n_train3B[0]-1]] << endl;
   for (i=0; i < n_train3B[0]; i++) ids_selected3o[0][i] = ids_selected[3][i];
   sort(ids_selected3o[0], ids_selected3o[0]+n_train3B[0]);
   cout << "ntrain3B(1): " << n_train3B[1] << ", max_lev: " << levs[4][ids_selected[4][0]] << ", min_lev: " << levs[4][ids_selected[4][n_train3B[1]-1]] << endl;
   for (i = 0; i < n_train3B[1]; i++) ids_selected3o[1][i] = ids_selected[4][i];
   sort(ids_selected3o[1], ids_selected3o[1]+n_train3B[1]);
   cout << "ntrain3B(2): " << n_train3B[2] << ", max_lev: " << levs[5][ids_selected[5][0]] << ", min_lev: " << levs[5][ids_selected[5][n_train3B[2]-1]] << endl;
   for (i = 0; i < n_train3B[2]; i++) ids_selected3o[2][i] = ids_selected[5][i];
   sort(ids_selected3o[2], ids_selected3o[2]+n_train3B[2]);
   cout << "ntrain3B(3): " << n_train3B[3] << ", max_lev: " << levs[6][ids_selected[6][0]] << ", min_lev: " << levs[6][ids_selected[6][n_train3B[3]-1]] << endl;
   for (i = 0; i < n_train3B[3]; i++) ids_selected3o[3][i] = ids_selected[6][i];
   sort(ids_selected3o[3], ids_selected3o[3]+n_train3B[3]);
   ids_selected3 = new int[nstr];
   for (i=0; i < n_train3B[0]; i++) ids_selected3[i] = ids_selected3o[0][i];
   idit = set_difference(ids_selected3o[1], ids_selected3o[1]+n_train3B[1], ids_selected3, ids_selected3+n_train3B[0], ids_selected3+n_train3B[0]);
   ndiff = idit - (ids_selected3 + n_train3B[0]);
   n_train3 = n_train3B[0] + ndiff;
   sort(ids_selected3, ids_selected3+n_train3);
   idit = set_difference(ids_selected3o[2], ids_selected3o[2]+n_train3B[2], ids_selected3, ids_selected3+n_train3, ids_selected3+n_train3);
   ndiff = idit - (ids_selected3 + n_train3);
   n_train3 += ndiff;
   sort(ids_selected3, ids_selected3+n_train3);
   idit = set_difference(ids_selected3o[3], ids_selected3o[3]+n_train3B[3], ids_selected3, ids_selected3+n_train3, ids_selected3+n_train3);
   ndiff = idit - (ids_selected3 + n_train3);
   n_train3 += ndiff;
   sort(ids_selected3, ids_selected3+n_train3);
   ids_selected23 = new int[nstr];
   for (i=0; i < n_train2; i++) ids_selected23[i] = ids_selected2[i];
   idit = set_difference(ids_selected3, ids_selected3+n_train3, ids_selected2, ids_selected2+n_train2, ids_selected23+n_train2);
   ndiff = idit - (ids_selected23+n_train2);
   n_train23 = n_train2 + ndiff;
   sort(ids_selected23, ids_selected23+n_train23);
   for (i = 0; i < nstr; i++) itmp[i] = i;
   set_difference(itmp, itmp+nstr, ids_selected23, ids_selected23+n_train23, ids_selected23+n_train23);
   ndesc23 = ndesc2 + ndesc3;
   calculate_linear_regression(nstr, ndesc23, ndesc, "descs.bin", ids_selected23, n_train23, Yc);*/
//   ndesc4 = descs.GetN4BDescriptors();
//   cout << "Number of 4B descriptors: " << ndesc4 << endl;
//   ndesc40 = descs.GetN4BDescriptors(0);
//   ndesc41 = descs.GetN4BDescriptors(1);
//   ndesc42 = descs.GetN4BDescriptors(2);
//   ndesc43 = descs.GetN4BDescriptors(3);
//   ndesc44 = descs.GetN4BDescriptors(4);
//   cout << "   type 0: " << ndesc40 << endl;
//   cout << "   type 1: " << ndesc41 << endl;
//   cout << "   type 2: " << ndesc42 << endl;
//   cout << "   type 3: " << ndesc43 << endl;
//   cout << "   type 4: " << ndesc44 << endl;
//   wmatc4 = new double[nstr*ndesc4];
//   tkns = Tokenize(g_params.tss4B, " ");
//   if (tkns.size() != 5) {
//      cerr << "Input error reading TRAINING_SET_SIZE_4B" << endl;
//      goto end;
//   }
//   for (i = 0; i < 5; i++) {
//      n_train4B[i] = atoi(tkns[i].c_str());
//      ids_selected4o[i] = new int[n_train4B[i]];
//   }
//   for (i = 0; i < nstr; i++) {
//      k = i*ndesc + ndesc23;
//      for (j = 0; j < ndesc40; j++) wmatc4[i*ndesc40+j] = wmatc[k+j];
//   }
//   order_by_leverages(nstr, ndesc40, wmatc4, ids_selected, levs);
//   cout << "ntrain: " << n_train4B[0] << ", max_lev: " << levs[ids_selected[0]] << ", min_lev: " << levs[ids_selected[n_train4B[0]-1]] << endl;
//   for (i = 0; i < n_train4B[0]; i++) ids_selected4o[0][i] = ids_selected[i];
//   sort(ids_selected4o[0], ids_selected4o[0]+n_train4B[0]);
//   for (i = 0; i < nstr; i++) {
//      k = i*ndesc + ndesc23 + ndesc40;
//      for (j = 0; j < ndesc41; j++) wmatc4[i*ndesc41+j] = wmatc[k+j];
//   }
//   order_by_leverages(nstr, ndesc41, wmatc4, ids_selected, levs);
//   cout << "ntrain: " << n_train4B[1] << ", max_lev: " << levs[ids_selected[0]] << ", min_lev: " << levs[ids_selected[n_train4B[1]-1]] << endl;
//   for (i = 0; i < n_train4B[1]; i++) ids_selected4o[1][i] = ids_selected[i];
//   sort(ids_selected4o[1], ids_selected4o[1]+n_train4B[1]);
//   for (i = 0; i < nstr; i++) {
//      k = i*ndesc + ndesc23 + ndesc40 + ndesc41;
//      for (j = 0; j < ndesc42; j++) wmatc4[i*ndesc42+j] = wmatc[k+j];
//   }
//   order_by_leverages(nstr, ndesc42, wmatc4, ids_selected, levs);
//   cout << "ntrain: " << n_train4B[2] << ", max_lev: " << levs[ids_selected[0]] << ", min_lev: " << levs[ids_selected[n_train4B[2]-1]] << endl;
//   for (i = 0; i < n_train4B[2]; i++) ids_selected4o[2][i] = ids_selected[i];
//   sort(ids_selected4o[2], ids_selected4o[2]+n_train4B[2]);
//   for (i = 0; i < nstr; i++) {
//      k = i*ndesc + ndesc23 + ndesc40 + ndesc41 + ndesc42;
//      for (j = 0; j < ndesc43; j++) wmatc4[i*ndesc43+j] = wmatc[k+j];
//   }
//   order_by_leverages(nstr, ndesc43, wmatc4, ids_selected, levs);
//   cout << "ntrain: " << n_train4B[3] << ", max_lev: " << levs[ids_selected[0]] << ", min_lev: " << levs[ids_selected[n_train4B[3]-1]] << endl;
//   for (i = 0; i < n_train4B[3]; i++) ids_selected4o[3][i] = ids_selected[i];
//   sort(ids_selected4o[3], ids_selected4o[3]+n_train4B[3]);
//   for (i = 0; i < nstr; i++) {
//      k = i*ndesc + ndesc23 + ndesc40 + ndesc41 + ndesc42 + ndesc43;
//      for (j = 0; j < ndesc44; j++) wmatc4[i*ndesc44+j] = wmatc[k+j];
//   }
//   order_by_leverages(nstr, ndesc44, wmatc4, ids_selected, levs);
//   cout << "ntrain: " << n_train4B[4] << ", max_lev: " << levs[ids_selected[0]] << ", min_lev: " << levs[ids_selected[n_train4B[4]-1]] << endl;
//   for (i = 0; i < n_train4B[4]; i++) ids_selected4o[4][i] = ids_selected[i];
//   sort(ids_selected4o[4], ids_selected4o[4]+n_train4B[4]);
end:
   for (i=0; i < 5; i++) delete [] ids_selected4o[i];
   delete [] ids_selected23;
   delete [] ids_selected3;
   for (i=0; i < 4; i++) delete [] ids_selected3o[i];
   delete [] itmp;
   delete [] ids_selected2;
   delete [] Yc;
   for (i=0; i < 3; i++) delete [] ids_selected2o[i];
//   delete [] wmatc_2;
//   delete [] wmatc;
   for (i=0; i < 12; i++) {
      delete [] levs[i];
      delete [] ids_selected[i];
   }
   delete [] avgs;
   delete [] stdevs;
   delete [] ngp;
   delete [] stypes4;
   delete [] types4;
   delete [] stypes3;
   delete [] types3;
   delete [] types2;
   delete [] dmax;
   delete [] dmin;
   delete [] v;
   delete [] Y;
}
